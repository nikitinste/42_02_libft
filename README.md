# 42_02_libft
My 21-school learning library project

• memset	+	void *memset(void *b, int c, size_t len);	\ заполнить байтовую строку определённым значением байта
			+	# include <string.h>		\ memset() заполняет первые len байтов той области памяти, на которую указывает b, постоянным байтом c.
			+	Функция memset() возвращает указатель на область памяти b.

• bzero		+	void bzero(void *s, size_t n);	\записать нули в байтовую строку (записывает пустые байты)
			+	# include <strings.h>	\ Функция bzero () записывает n нулевых байтов в строку s. Если n равно нулю, bzero () ничего не делает.
			+	void

• memcpy	+	void *memcpy(void *restrict dst, const void *restrict src, size_t n);	\ копировать область памяти
			+	# include <string.h>		\ Функция memcpy () копирует n байтов из области памяти src в область памяти dst. Если dst и src перекрываются, поведение не определено. Приложения, в которых dst и src могут перекрываться, должны использовать memmove (3).
			+	Функция memcpy () возвращает исходное значение dst (возвращает указатель на dst).

• memccpy	+	void *memccpy(void *restrict dst, const void *restrict src, int c, size_t n);	\ скопировать строку до появления символа
			+	# include <string.h>	\ Функция memccpy () копирует байты из строки src в строку dst. Если символ c (преобразованный как unsigned char) встречается в строке src, копирование останавливается и возвращается указатель на байт следующий за последним скопированным (c) в строке dst. В противном случае копируется n байтов и возвращается указатель NULL. Исходные и целевые строки не должны перекрываться, так как в этом случае поведение не определено.

• memmove	+	void *memmove(void *dst, const void *src, size_t len);	\ копировать строку байтов (копировать область памяти)
			+	# include <string.h>	\ Функция memmove () копирует len байт из строки src в строку dst. Две строки могут перекрываться; копия всегда выполняется неразрушающим образом.
			+	Функция memmove () возвращает исходное значение dst (возвращает указатель на dst).

• memchr	+	void *memchr(const void *s, int c, size_t n);	\ найти байт в байтовой строке (ведет поиск символа в памяти)
			+	# include <string.h>	\ Функция memchr() ищет символ c в первых n байтах той области памяти, на которую указывает s. Совпадение первого байта с c (представленным как unsigned char) останавливает выполнение операции.
			+	Функция memchr () возвращает указатель на расположенный байт или NULL, если такого байта не существует в n байтах.

• memcmp	+	int memcmp(const void *s1, const void *s2, size_t n);	\ сравнить строку байтов (область памяти)
			+	# include <string.h>	\ Функция memcmp () сравнивает байтовую строку s1 с байтовой строкой s2. Предполагается, что обе строки имеют длину n байтов.
			+	Функция memcmp () возвращает ноль, если две строки идентичны, в противном случае возвращает разницу между двумя первыми различающимися байтами (обрабатываются как значения unsigned char, так что `\ 200' больше, чем `\ 0', например). Строки нулевой длины всегда одинаковы. Это поведение не требуется для C, а переносимый код должен зависеть только от знака возвращаемого значения. (This behavior is not required by C and portable code should only depend on the sign of the returned value).

• strlen	+	size_t strlen(const char *s);	\ Найти длину строки (определяет длину строки фиксированной длины)
			+	# include <string.h>	\ Функция strlen () вычисляет длину строки s.
			+	Функция strlen () возвращает количество символов, предшествующих завершающему символу NUL.

• strdup	+	char *strdup(const char *s1);	\ Сохранить копию строки (дублирует строку)
			+	# include <string.h>	\ Функция strdup () выделяет достаточную память для копии строки s1, делает копию и возвращает указатель на нее. Память под новую строку выделятся с помощью malloc. Указатель впоследствии может быть использован как аргумент функции free (3).
			+	Если доступно недостаточное количество памяти, возвращается NULL, а errno - устанавливается в ENOMEM <- с этим не работаем. !!!

• strcpy	+	char *strcpy(char * dst, const char * src);	\ Копировать строку
			+	# include <string.h>	\ Функция strcpy () копирует строку src в dst (включая завершающий символ '\0'). Исходные и целевые строки не должны перекрываться, так как поведение не определено.
			+	Функция strcpy () возвращает dst (возвращают указатель на результирующую строку dst).

• strncpy	+	char *strncpy(char * dst, const char * src, size_t len);	\ Копировать строку на len символов
			+	# include <string.h>	\ Функция strncpy () копирует не более len символов из src в dst. Если src длиннее len символов, остаток dst заполняется символами `\ 0 '. В противном случае dst не завершается (если в n байтах строки src нет нулевого байта, то строка результата не будет заканчиваться символом `\0'). Исходные и целевые строки не должны перекрываться, так как поведение не определено.
			+		Функция strncpy () возвращает dst (возвращают указатель на результирующую строку dst).

• strcat	+	char *strcat(char *restrict s1, const char *restrict s2);	\ конкатенация двух строк
			+	# include <string.h>	\ Функция strcat добавляет копию нуль-терминированной строки s2 в конец нуль-терминированной строки s1, а затем добавляют завершающий `\ 0 '. Строка s1 должна иметь достаточное пространство для хранения результата. Исходные и целевые строки не должны перекрываться, так как поведение не определено.
			+	The strcat() and strncat() functions return the pointer s1.

• strncat	+	char *strncat(char *restrict s1, const char *restrict s2, size_t n);	\ конкатенация двух строк
			+	# include <string.h>	\ Функция strncat () добавляет копию нуль-терминированной строки s2 в конец нуль-терминированной строки s1, а затем добавляют завершающий `\ 0 '. Строка s1 должна иметь достаточное пространство для хранения результата. Функция strncat () добавляет не более n символов из s2, а затем добавляет завершающий `\ 0 '. Исходные и целевые строки не должны перекрываться, так как поведение не определено.
			+	The strcat() and strncat() functions return the pointer s1.

• strlcat	+	size_t strlcat(char * restrict dst, const char * restrict src, size_t size);	\ Фиксированные по размеру копирование и конкатенация
			+	# include <string.h>	\ Функции strlcpy () и strlcat () копируют и объединяют строки соответственно. Они предназначены для более безопасной, более последовательной и менее подверженной ошибкам замены для strncpy (3) и strncat (3). В отличие от этих функций, strlcpy () и strlcat () берут полный размер буфера (а не только длину) и гарантируют NUL-завершение результата (если size больше 0 или, в случае strlcat () , если в dst есть хотя бы один байт). Обратите внимание, что байт для NUL должен быть включен в size. Также обратите внимание, что strlcpy () и strlcat () работают только с настоящими строками ``C''. Это означает, что для strlcpy () src должен иметь NUL-конец и для strlcat () оба src и dst должны быть NUL-завершены.

			Функция strlcpy () копирует до размера - 1 символ из строки с завершенным нулем строки src в dst, NUL - завершает результат.

			Функция strlcat () добавляет нуль-терминированную строку src, в конец dst. Это добавится в максимальном size - strlen(dst) - 1 байт, и NUL - завершение результата.

			Исходные и целевые строки не должны перекрываться, так как поведение не определено.

			+	Функции strlcpy () и strlcat () возвращают общую длину строки, которую они пытались создать. Для strlcpy () это означает длину src. Для strlcat () это означает начальную длину dst плюс длину src. Хотя это может показаться несколько запутанным, это было сделано для упрощения определения усечения.

			Обратите внимание, однако, что если strlcat() перемещает size символов без нахождения NUL, длина строки считается size, а строка назначения не будет NUL-terminated (поскольку для NUL не было места). Это удерживает strlcat () от конца строки. На практике это не должно происходить (поскольку это означает, что либо размер неправильный, либо dst не является правильной строкой `` C ''). Проверка существует для предотвращения возможных проблем с безопасностью в некорректном коде.

Наблюдения, в попытках разобраться:

	- Входящий параметр size включает в себя место под '\0', т е при значении  size = 5 в dst при полном заполнении будет 4 символа + '\0' (при этом ф-ция возвращает общее кол-во символов в обоих исходных строках не считая нуль-терминаторов).

	- Если  size меньше реальной длины изначальной строки dst, strlcat никак её не меняет, а возвращаемое значение равно кол-ву символов в src + size.

Описание предположительного поведения ф-ции:

	Ф-ция пытается прочитать size символов из строки dst, если они заканчиваются (их меньше size), ф-ция записывает после них символы из строки src до общего кол-ва (size - 1), последний символ остаётся для  '\0'.

	Возвращаемое значение равно кол-ву прочитанных символов из строки dst, ограниченному size + кол-ву символов в src

• strchr	+	char *strchr(const char *s, int c);		\ Найти символ в строке
			+	# include <string.h>	\ Функция strchr () находит первое совпадние с "c" (преобразованное в char) в строке, на которую указывает s. Конечный нулевой символ считается частью строки; поэтому, если "c" является `\0', функции ищут завершающий `\0'.
			+	Функции strchr () и strrchr () возвращают указатель на найденный символ или NULL, если символа не оказалось в строке.

• strrchr	+	char *strrchr(const char *s, int c);	\ Найти символ в строке
			+	# include <string.h>	\ Функция strrchr () идентична strchr (), за исключением того, что находит последнее совпадение с "c".
			+	Функции strchr () и strrchr () возвращают указатель на найденный символ или NULL, если символа не оказалось в строке.

			то же, что выше, + ft_strlen

• strstr	+	char *strstr(const char *haystack, const char *needle);	\ Ищет подстроку в строке
			+	# include <string.h>	\	Функция strstr() ищет првое совпадение нуль-терминированной строки needle (иглы) в нуль-терминнированной строке haystack (в стоге сена). (Завершающий символ `\0' не сравнивается).
			+	Если needle - пустая строка, возвращается haystack; если needle в haystack не обнаружена, возвращается NULL; в противном случае возвращается указатель на первый символ первой обнаруженной needle.

• strnstr	+	char *strnstr(const char *haystack, const char *needle, size_t len);	\ Ищет подстроку в строке
			+	# include <string.h>	\	Функция strnstr () ищет првое совпадение нуль-терминированной строки needle (иглы) в нуль-терминнированной строке haystack (в стоге сена), где выполняется поиск не более len символов. Символы, которые находятся после символа `\0', не проверяются. Поскольку функция strnstr () является специфичным для FreeBSD API, ее следует использовать только тогда, когда переносимость не является проблемой.
			+	Если needle - пустая строка, возвращается haystack; если needle в haystack не обнаружена, возвращается NULL; в противном случае возвращается указатель на первый символ первой обнаруженной needle.

• strcmp	+	int strcmp(const char *s1, const char *s2);	\ Сравнение строк
			+	# include <string.h>	\	Функция strcmp лексикографически сравнивает нуль-терминированные строки s1 и s2.
			+	Функции strcmp () и strncmp () возвращают целое число, большее, равное или меньшее, чем 0, в соответствии с тем, что строка s1 больше, равна или меньше строки s2. Сравнение выполняется с использованием unsigned characters, так что `\ 200 'больше, чем '\0'.

• strncmp	+	int strncmp(const char *s1, const char *s2, size_t n);	\ Сравнение строк
			+	# include <string.h>	\	Функция strncmp лексикографически сравнивает нуль-терминированные строки s1 и s2, но не более чем n символов. Поскольку strncmp () предназначен для сравнения строк, а не двоичных данных, символы, которые появляются после символа `\ 0 ', не сравниваются.
			+	Функции strcmp () и strncmp () возвращают целое число, большее, равное или меньшее, чем 0, в соответствии с тем, что строка s1 больше, равна или меньше строки s2. Сравнение выполняется с использованием неподписанных символов, так что `\ 200 'больше, чем` \ 0'.

• atoi		+	int atoi(const char *str);	\ convert ASCII string to integer
			+	# include <stdlib.h>	\	Функция atoi () преобразует начальную часть строки, на которую указывает str на int. It is equivalent to:	(int)strtol(str, (char **)NULL, 10);
			+	! Функция atoi () не должна влиять на значение errno при ошибке.

			MAN strtol

			long int strtol(const char *nptr, char **endptr, int base);

			Функция strtol () преобразует начальную часть строки в nptr в длинное целое значение в соответствии с заданным основанием, которое должно быть от 2 до 36 включительно, или иметь специальное значение 0.

       		Строка может начинаться с произвольного количества пробелов (как определено isspace (3)), за которым следует один необязательный знак «+» или «-». Если base равно нулю или 16, строка может включать префикс «0x» или «0X», и число будет читаться в базе 16; в противном случае нулевое основание принимается за 10 (десятичное), если следующий символ не равен «0», в этом случае он принимается за 8 (восьмеричное).

       		Остальная часть строки преобразуется в длинное значение типа int очевидным образом, останавливаясь на первом символе, который не является допустимой цифрой в данной базе. (В основаниях выше 10 буква «A» в верхнем или нижнем регистре обозначает 10, «B» обозначает 11 и т. Д., Причем «Z» обозначает 35).

       		Если endptr не равен NULL, strtol () сохраняет адрес первого недопустимого символа в * endptr. Если цифр не было вообще, strtol () сохраняет исходное значение nptr в * endptr (и возвращает 0). В частности, если * nptr не равно «\ 0», а ** endptr равно «\ 0» при возврате, вся строка действительна.


			Функция strtol () возвращает результат преобразования, если только значение не будет уменьшено или переполнено. Если происходит переполнение, strtol () возвращает LONG_MIN. Если происходит переполнение, strtol () возвращает LONG_MAX. В обоих случаях для errno установлено значение ERANGE. Точно то же самое верно для strtoll () (с LLONG_MIN и LLONG_MAX вместо LONG_MIN и LONG_MAX).

       		isspace ()

            проверяет наличие пробелов. В локалях "C" и "POSIX" это: пробел, подача формы ('\f'), перевод строки ('\n'), возврат каретки ('\r'), горизонтальная табуляция ('\t' ) и вертикальная вкладка ('\v').

• isalpha	+	int isalpha(int c);	\ alphabetic character test
			+	# include <ctype.h>	\ Функция isalpha () проверяет любой символ, для которого isupper (3) или islower (3) истинно. Значение аргумента должно быть представлено как символ без знака или значение EOF. В наборе символов ASCII это включает следующие символы (которым предшествуют их числовые значения, в восьмеричном):

			101 ``A''     102 ``B''     103 ``C''     104 ``D''     105 ``E''
     		106 ``F''     107 ``G''     110 ``H''     111 ``I''     112 ``J''
     		113 ``K''     114 ``L''     115 ``M''     116 ``N''     117 ``O''
     		120 ``P''     121 ``Q''     122 ``R''     123 ``S''     124 ``T''
     		125 ``U''     126 ``V''     127 ``W''     130 ``X''     131 ``Y''
     		132 ``Z''     141 ``a''     142 ``b''     143 ``c''     144 ``d''
     		145 ``e''     146 ``f''     147 ``g''     150 ``h''     151 ``i''
     		152 ``j''     153 ``k''     154 ``l''     155 ``m''     156 ``n''
     		157 ``o''     160 ``p''     161 ``q''     162 ``r''     163 ``s''
     		164 ``t''     165 ``u''     166 ``v''     167 ``w''     170 ``x''
     		171 ``y''     172 ``z''

    oct		101 - 132, 141 - 172

    dec		65  - 90,	97 - 122

     		+	The isalpha() function returns zero if the character tests false and returns non-zero if the character tests true.

• isdigit	+	int isdigit(int c);	\ decimal-digit character test
			+	# include <ctype.h>	\ Функция isdigit () проверяет символ десятичной цифры. Независимо от языка, это включает только следующие символы:

			``0''         ``1''         ``2''         ``3''         ``4''
    		``5''         ``6''         ``7''         ``8''         ``9''

    		Значение аргумента должно быть представлено как символ без знака или значение EOF.

    		+	The isdigit() and isnumber() functions return zero if the character tests false and return non-zero if the character tests true.

• isalnum	+	int isalnum(int c);	\ alphanumeric character test
			+	# include <ctype.h>	\ Функция isalnum() проводит тест для любого символа, для которого isalpha(3) или isdigit(3) истинно. Значение аргумента должно быть представлено как символ без знака или значение EOF. В наборе символов ASCII это включает следующие символы (которым предшествуют их числовые значения, в восьмеричном):

			060 ``0''     061 ``1''     062 ``2''     063 ``3''     064 ``4''
    		065 ``5''     066 ``6''     067 ``7''     070 ``8''     071 ``9''
    		101 ``A''     102 ``B''     103 ``C''     104 ``D''     105 ``E''
    		106 ``F''     107 ``G''     110 ``H''     111 ``I''     112 ``J''
    		113 ``K''     114 ``L''     115 ``M''     116 ``N''     117 ``O''
    		120 ``P''     121 ``Q''     122 ``R''     123 ``S''     124 ``T''
    		125 ``U''     126 ``V''     127 ``W''     130 ``X''     131 ``Y''
    		132 ``Z''     141 ``a''     142 ``b''     143 ``c''     144 ``d''
    		145 ``e''     146 ``f''     147 ``g''     150 ``h''     151 ``i''
    		152 ``j''     153 ``k''     154 ``l''     155 ``m''     156 ``n''
    		157 ``o''     160 ``p''     161 ``q''     162 ``r''     163 ``s''
    		164 ``t''     165 ``u''     166 ``v''     167 ``w''     170 ``x''
    		171 ``y''     172 ``z''

    		+	The isalnum() function returns zero if the character tests false and returns non-zero if the character tests true.

• isascii	+	int isascii(int c);	\ test for ASCII character
			+	# include <ctype.h>	\ Функция isascii () проверяет символ ASCII, который является любым символом между 0 и восьмеричным номером 0177 включительно. (dec 0 - 127)

• isprint	+	int isprint(int c);	\ Тест на печатные символы (включая пробел)
			+	# include <ctype.h>	\ Функция isprint () проверяет любой символ печати, включая пробел (`'). Значение аргумента должно быть представлено как символ без знака или значение EOF. В наборе символов ASCII это включает следующие символы (которым предшествуют их числовые значения, в восьмеричном):

			040 sp        041 ``!''     042 ``"''     043 ``#''     044 ``$''
    		045 ``%''     046 ``&''     047 ``'''     050 ``(''     051 ``)''
    		052 ``*''     053 ``+''     054 ``,''     055 ``-''     056 ``.''
    		057 ``/''     060 ``0''     061 ``1''     062 ``2''     063 ``3''
    		064 ``4''     065 ``5''     066 ``6''     067 ``7''     070 ``8''
    		071 ``9''     072 ``:''     073 ``;''     074 ``<''     075 ``=''
    		076 ``>''     077 ``?''     100 ``@''     101 ``A''     102 ``B''
    		103 ``C''     104 ``D''     105 ``E''     106 ``F''     107 ``G''
    		110 ``H''     111 ``I''     112 ``J''     113 ``K''     114 ``L''
    		115 ``M''     116 ``N''     117 ``O''     120 ``P''     121 ``Q''
    		122 ``R''     123 ``S''     124 ``T''     125 ``U''     126 ``V''
    		127 ``W''     130 ``X''     131 ``Y''     132 ``Z''     133 ``[''
    		134 ``\''     135 ``]''     136 ``^''     137 ``_''     140 ```''
    		141 ``a''     142 ``b''     143 ``c''     144 ``d''     145 ``e''
    		146 ``f''     147 ``g''     150 ``h''     151 ``i''     152 ``j''
    		153 ``k''     154 ``l''     155 ``m''     156 ``n''     157 ``o''
    		160 ``p''     161 ``q''     162 ``r''     163 ``s''     164 ``t''
    		165 ``u''     166 ``v''     167 ``w''     170 ``x''     171 ``y''
    		172 ``z''     173 ``{''     174 ``|''     175 ``}''     176 ``~''

    		oct 40 - 47, 50 - 57, 60 - 67, 70 - 77, 100 - 107, 110 - 117, 120 - 127, 130 - 137, 140 - 147, 150 - 157, 160 - 167, 170 - 176

    		dec 32 - 126

    		+	The isprint() function returns zero if the character tests false and returns non-zero if the character tests true.

• toupper	+	int toupper(int c);	\ lower case to upper case letter conversion
			+	# include <ctype.h>	\ Функция toupper () преобразует строчную букву в соответствующую верхнюю букву. Аргумент должен быть представлен как символ без знака или значение EOF (преобразует символ c в заглавный, если это возможно).
			+	Если аргумент является строчной буквой, функция toupper () возвращает соответствующую верхнюю букву, если она есть; в противном случае аргумент возвращается без изменений (Возвращается преобразованный символ или c, если преобразование невозможно).

• tolower	+	int tolower(int c);	\ upper case to lower case letter conversion
			+	# include <ctype.h>	\ Функция tolower () преобразует верхнюю букву в соответствующую строчную букву. Аргумент должен быть представлен как символ без знака или значение EOF (преобразует символ c в строчной, если это возможно).
			+	Если аргумент является строчной буквой, функция tolower () возвращает соответствующую строчную букву, если она есть; в противном случае аргумент возвращается без изменений (Возвращается преобразованный символ или c, если преобразование невозможно).

V.3 Part 2 - Additional functions

В этой второй части, вы должны написать набор функций, которые или не включены в libc, или входят в иноой форме. Некоторые из этих функций могут быть полезны для написания функций Части 1.

• ft_memalloc	+	void * ft_memalloc(size_t size);	\ -> Размер памяти, которая должна быть выделена \ Выделенная область памяти ->
				+	Выделяет (с malloc (3)) и возвращает «новую» область памяти. Выделенная память инициализируется равным 0. Если распределение не выполняется, функция возвращает NULL.
				+	malloc (3)

• ft_memdel		+	void ft_memdel(void **ap);	\ -> Адрес указателя, который требует освобождения своей памяти и установлен в NULL. \ None ->
				+	Принимает в качестве параметра адрес области памяти, которая должна быть освобождена с помощью free (3), затем помещает указатель в NULL.
				+	free (3)

				MAN free:

				void	free(void *ptr);

				Функции malloc (), calloc (), valloc (), realloc () и reallocf () выделяют память. Выделенная память выровнена так, что она может использоваться для любого типа данных, включая типы, связанные с AltiVec и SSE. Функция free () освобождает выделения, созданные с помощью предыдущих функций выделения.

				Функция free () освобождает выделение памяти, на которое указывает ptr. Если ptr является пустым указателем, никакая операция не выполняется.

				Функция free () ничего не возвращает.

• ft_strnew		+	char * ft_strnew(size_t size);	\ -> Размер строки, которую нужно выделить. \ Строка выделенная и инициализирована до 0. ->
				+	Выделяет (с malloc (3)) и возвращает «свежую» строку, заканчивающуюся '\0'. Каждый символ строки инициализируется в '\0'. Если распределение не выполняется, функция возвращает NULL.
				+	malloc (3)

• ft_strdel		+	void ft_strdel(char **as);	\ -> Адрес строки, который должен быть освобожден, и его указатель установленный в NULL. \ None ->
				+	Принимает в качестве параметра адрес строки, которая должна быть освобождена с помощью free (3), а затем устанавливает ее указатель на NULL.
				+	free (3)

• ft_strclr		+	void ft_strclr(char *s);	\ -> Строка, которая должна быть очищена. \ None ->
				+	Устанавливает каждый символ строки в значение '\0'.
				+	None

• ft_striter	+	void ft_striter(char *s, void (*f)(char *));	\ -> #1 Строка для итерации. \ -> #2 Функция, применяемая к каждому символу s. \ None ->
				+	Применяет функцию f к каждому символу строки, переданной как аргумент. Каждый символ передается по адресу в f, если необходимо.
				+	None

• ft_striteri	+	void ft_striteri(char *s, void (*f)(unsigned int, char *));	\ -> #1 Строка для итерации.
																				\ -> #2 Функция применяющаяся к каждому символу s и его индексу. \ None ->
				+	Применяет функцию f к каждому символу строки, переданной как аргумент, и передавая свой индекс в качестве первого аргумента. Каждый символ передается по адресу в f, если необходимо.
				+	None

• ft_strmap		+	char * ft_strmap(char const *s, char (*f)(char));	\ -> #1 The string to map.
																		\ -> #2 Функция, применяемая к каждому символу s.
																		\ «Свежая» строка, созданная из последовательных применений f ->
				+	Применяет функцию f к каждому символу строки, заданной в качестве аргумента, для создания «свежей» новой строки (с malloc (3)) в результате последовательного применения f.
				+	malloc (3)

• ft_strmapi	+	char * ft_strmapi(char const *s, char (*f)(unsigned int, char));	\ -> #1 The string to map.
																						\ -> #2 Функция применяемая к каждому символу s и его индексу.
																						\ «Свежая» строка, созданная из последовательных применений f ->
				+	Применяет функцию f к каждому символу строки, переданной как аргумент, указав свой индекс в качестве первого аргумента для создания «свежей» новой строки (с malloc (3)) в результате последовательных применений f.
				+	malloc (3)

• ft_strequ		+	int ft_strequ(char const *s1, char const *s2);	\ -> #1 Первая строка, которую нужно сравнить.
																	\ -> #2 Вторая строка, которую нужно сравнить.
																	\ 1 или 0 в соответствии с тем, что две строки идентичны или нет. ->
				+	Лексикографическое сравнение между s1 и s2. Если 2 строки идентичны, функция возвращает 1 или 0 в противном случае.
				+	None

• ft_strnequ	+	int ft_strnequ(char const *s1, char const *s2, size_t n);	\ -> #1 Первая строка, которую нужно сравнить.
																				\ -> #2 Вторая строка, которую нужно сравнить.
																				\ -> #3 Максимальное кол-во символов для сравнения.
																				\ 1 или 0 в соответствии с тем, что две строки идентичны или нет. ->
				+	Лексикографическое сравнение между s1 и s2 с точностью до n символов или до достижения '\0'. Если 2 строки идентичны, функция возвращает 1 или 0 в противном случае.
				+	None

• ft_strsub		+	char * ft_strsub(char const *s, unsigned int start, size_t len);	\ -> #1 Строка, из которой создается подстрока.
																						\ -> #2 Начальный индекс подстроки.
																						\ -> #3 Размер подстроки.
																						\ Подстрока ->
				+	Выделяет (с malloc (3)) и возвращает «свежую» подстроку из строки, указанной в качестве аргумента. Подстрока начинается с indexstart и имеет размер len. Если start и len не относятся к допустимой подстроке, поведение не определено. Если распределение не выполняется, функция возвращает NULL.
				+	malloc (3)

• ft_strjoin	+	char * ft_strjoin(char const *s1, char const *s2);	\ -> #1 Строка префикса.
																		\ -> #2 Строка суффикса
																		\ «Свежая» строка полученная в результате конкатенации двух строк. ->
				+	Выделяет (с malloc (3)) и возвращает «свежую» строку, заканчивающуюся '\0', результатом конкатенации s1 и s2. Если распределение не выполняется, функция возвращает NULL.
				+	malloc (3)

• ft_strtrim	+	char * ft_strtrim(char const *s);	\ -> Строка, подлежащая обрезанию. \ «Свежая» обрезанная строка или копия s. ->
				+	Выделяет (с malloc (3)) и возвращает копию строки, заданную как аргумент без пробелов в начале или в конце строки. Будут считаться пробелами следующие символы: ' ', '\n' '\t'. Если s не имеет пробелов в начале или в конце, функция возвращает копию s. Если распределение не выполняется, функция возвращает NULL.
				+	malloc (3)

• ft_strsplit	+	char ** ft_strsplit(char const *s, char c);	\ #1 -> Строка для разделения.
																\ #2 -> Символ разделителя.
																\ Массив «свежих» строк полученных в результате разделения. ->
				+	Выделяет (с помощью malloc (3)) и возвращает массив «свежих» строк (все заканчиваются на '\0', включая сам массив), полученный путем разделения s с использованием символа c в качестве разделителя. Если распределение не выполняется, функция возвращает NULL. Пример:
				ft_strsplit("*hello*fellow***students*", ’*’) возвратит массив ["hello", "fellow", "students"].
				+	malloc (3), free (3)

• ft_itoa		+	char * ft_itoa(int n);	\ -> Целое число, которое должно быть преобразовано в строку.
											\ The string representing the integer passed as argument. ->
				+	Выделите (с помощью malloc (3)) и верните «новую» строку, заканчивающуюся '\0', представляющую целое число n, указанное в качестве аргумента. Отрицательные числа должны поддерживаться. Если распределение не выполняется, функция возвращает NULL.
				+	malloc (3)

• ft_putchar	+	void ft_putchar(char c);	\ -> Символ для вывода. \ None ->
				+	Выводит символ c в стандартный вывод.
				+	write (2)

• ft_putstr		+	void ft_putstr(char const *s);	\ -> Строка для вывода. \ None ->
				+	Выводит строку s на стандартный вывод.
				+	write (2)

• ft_putendl	+	void ft_putendl(char const *s);	\ -> Строка для вывода. \ None ->
				+	Выводит строку s на стандартный вывод, а затем '\ n'.
				+	write (2)

• ft_putnbr		+	void ft_putnbr(int n);	\ -> Integer для вывода. \ None ->
				+	Выводит целое число n в стандартный вывод.
				+	write (2)

• ft_putchar_fd	+	void ft_putchar_fd(char c, int fd);	\ -> #1 Символ для вывода. \ -> #2 Файловый дескриптор \ None ->
				+	Выводит символ c в файловый дескриптор fd.
				+	write (2)

• ft_putstr_fd	+	void ft_putstr_fd(char const *s, int fd);	\ -> #1 Строка для вывода. \ -> #2 Файловый дескриптор \ None ->
				+	Выводит строку s в дескриптор файла fd.
				+	write (2)

• ft_putendl_fd	+	void ft_putendl_fd(char const *s, int fd);	\ -> #1 Строка для вывода. \ -> #2 Файловый дескриптор \ None ->
				+	Выводит строку s в дескриптор файла fd, за которым следует '\n'.
				+	write (2)

• ft_putnbr_fd	+	void ft_putnbr_fd(int n, int fd);	\ -> #1 Integer для вывода. \ -> #2 Файловый дескриптор \ None ->
				+	Выводит целое число n в дескриптор файла fd.
				+	write (2)



VI	Bonus part:

• ft_lstnew		+	t_list *ft_lstnew(void const *content, size_t content_size);	\ -> #1 Контент для добавления в новую ссылку.
																					\ -> #2 Размер содержимого новой ссылки.
																					\ Новая ссылка. ->
				+	Распределяет (с помощью malloc (3)) и возвращает «свежую» ссылку. Переменные content и content_size новой ссылки инициализируются копированием параметров функции. Если параметр content имеет значение nul, переменная content инициализируется в NULL, а переменная content_size инициализируется в 0, независимо от значения параметра content_size. Переменная next инициализируется значением NULL. Если распределение завершается неудачно, функция возвращает NULL.
				+	malloc(3), free(3)

• ft_lstdelone	+	void ft_lstdelone(t_list **alst, void (*del)(void *, size_t));	\ -> Адрес указателя на ссылку, которая должна быть освобождена.
																					\ None ->
				+	Принимает в качестве параметра адрес указателя на ссылку и освобождает память содержимого ссылки, используя функцию del, заданную в качестве параметра, а затем освобождает память ссылки с помощью free (3). Память next не должна быть освобождена ни при каких обстоятельствах. Наконец, указатель на только что освобожденную (free) ссылку должен быть установлен в NULL (очень похоже на функцию ft_memdel в обязательной части).
				+	free(3)

• ft_lstdel		+	void ft_lstdel(t_list **alst, void (*del)(void *, size_t));	\ -> Адрес указателя на первую ссылку списка, который необходимо освободить.
																				\ None ->
				+	Принимает в качестве параметра адрес указателя на ссылку и освобождает память этой ссылки и всех последующих ссылок, используя функции del и free (3). Наконец, указатель на только что освобожденную ссылку должен быть установлен в NULL (очень похоже на функцию ft_memdel из обязательной части).
				+	free(3)

• ft_lstadd		+	void ft_lstadd(t_list **alst, t_list *new);	\ -> #1 Адрес указателя на первую ссылку списка.
																\ -> #2 Ссылка для добавления в начало списка.
																\ None ->
				+	Добавляет элемент new в начало списка.
				+	None.

• ft_lstiter	+	void ft_lstiter(t_list *lst, void (*f)(t_list *elem));	\ -> #1 Указатель на первую ссылку списка.
																			\ -> #2 Адрес функции, применяемой к каждой ссылке в списке.
																			\ None ->
				+	Итерирует список lst и применяет функцию f к каждой ссылке.
				+	None.

• ft_lstmap		+	t_list * ft_lstmap(t_list *lst, t_list *(*f)(t_list *elem));	\ -> #1 Указатель на первую ссылку списка.
																					\ -> #2 Адрес функции, применяемой к каждой ссылке в списке.
																					\ Новый список ->
				+	Итерирует список lst и применяет функцию f к каждой ссылке, чтобы создать «свежий» список (используя malloc (3)), полученный в результате последовательных применений f. Если распределение завершается неудачно, функция возвращает NULL.
				+	malloc(3), free(3).

Extra functions:

void		ft_lstfree(void *content, size_t size);		- освобождает содержимое списка по void* указателю, инициализировав перед этим size байт области памяти в 0 посредством ft_bzero

int			ft_lstaddnext(t_list **alst, void const *content, size_t content_size);		- создаёт элемент списка, наполняет его содержимым и добавляет его в конец списка

void		ft_lstdelfirst(t_list **alst, void (*del)(void *, size_t));		- удаляет 1-й эл-т списка

int			ft_lstcount(t_list	*addr);		- подсчет эл-тов в списке

int			ft_abs(int nbr);		- возвращает модуль числа

char		*ft_arrjoin(char **arr, int len);		- склеивает массив в строку (выделенную) разделя эл-ты массива пробелами

char		**ft_strsplitspaces(char const *s); 	- то же что и ft_strsplit только по всем пробельным символам в качестве разделителя

t_list		*ft_lstcpy(t_list *src, t_list *dst);	- копирует последовательность листов

void		ft_lstswap(t_list *prev_a, t_list *a, t_list *prev_b, t_list *b);	- меняет местами любые 2 эл-та списка



t_dllist	*ft_dllnew(void const *content, size_t content_size);	- создаёт эл-т двусвязного списка

void		ft_dlldelone(t_dllist **alst, void (*del)(void*, size_t));	- удаляет эл-т двусвязного списка

void		ft_dlldeltoright(t_dllist **alst, void (*del)(void*, size_t));	- удаляет этот и все последующие эл-ты двусвязного списка слева направо

void		ft_dlldeltoleft(t_dllist **alst, void (*del)(void*, size_t));	- удаляет этот и все последующие эл-ты двусвязного списка справа налево

void		ft_dlldel(t_dllist **alst, void (*del)(void*, size_t)); - удаляет этот эл-т и весь список в обе стороны

void		ft_lstaddtoleft(t_dllist **alst, t_dllist *new);	- помещает эл-т слева от входящего эл-та (*alst) двусвязного списка

void		ft_lstaddtoright(t_dllist **alst, t_dllist *new);	- помещает эл-т справа от входящего эл-та (*alst) двусвязного списка

int			ft_dlladdnextr(t_dllist **alst, void const *content, size_t content_size); - создаёт элемент списка, наполняет его содержимым и добавляет его в конец списка справа

int			ft_dlladdnextl(t_dllist **alst, void const *content, size_t content_size); - создаёт элемент списка, наполняет его содержимым и добавляет его в конец списка слева

void		ft_dllswap(t_dllist *a, t_dllist *b);	- меняет местами содержимое 2-х эл-тов двусвязного списка (и значение content_size)

t_dllist	*ft_dllcpyr(t_dllist *src, t_dllist *dst);	- копирует последовательность эл-тов двусвязного списка начиная с текущего вправо;

t_dllist	*ft_dllcpyl(t_dllist *src, t_dllist *dst);	- копирует последовательность эл-тов двусвязного списка начиная с текущего влево;

t_dllist	*ft_dllcpy(t_dllist *src, t_dllist *dst);	- копирует последовательность эл-тов двусвязного списка начиная с текущего вправо и влево (полностью);

char		*ft_nstrjoin(int n, ...);	- ф-ция для конкатенации n-элементов в строку;
